<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[如何写一篇好的技术博客]]></title>
      <url>2017%2F01%2F04%2F%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E7%AF%87%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[在工作过程中，发现对很多东西都一知半解，不是很透澈，到头来很容易模糊，如果有一篇好的技术博客予以总结，一来即使忘记了，回国头来再看，仍然能够从自己的思路中恢复；二来总结一下，还会发现一些潜在问题；三来，有利于大家交流技术。很多大公司都有自己的内部技术博客平台，写好自己的技术博客，对一个技术人员来说，也有一定的成就感。 在网上查阅资料，经常可以看到一些技术博客，要么废话连篇、排版紊乱，要么代码占了篇幅的60%，有些甚至是错的，会让人产生误解。因此，在这总结一下一篇好的技术博客应该是怎样的，同时也规整自己的不良习惯。本篇博客纯属个人的一点想法，是个原则性的东西，切忌逐条对号入座啊。 本篇博客耗时2小时。 带着明确的目的写博客经常看到这种博客，为了写博客而写博客。比如一篇介绍socket接口的使用方法的博客，罗列了一堆代码，凑上几句话：“首先…，其次….，最后…”，就算OK。如果你的目的是“练习如何使用写博客的软件”，或者“罗列接口”，甚至“练习写作的方法”，那么可能达到了目的。但是我想，写一篇技术博客，首先是要明确该博客的目的，通常是学习一项技术、解决一个技术问题什么的，比如“学习Linux内存管理机制”，“解决kernel pannic的问题”，“打发时间”等。 不是所有的的事情都要写一篇博客来记录，要有自己的判断什么东西值的写，什么东西不值的写。 写自己的博客网上相互转载的帖子很多，一篇写的不错的博客经常会被转载，建议不要轻易转载别人的帖子，要写自己的博客。同样一个知识点，或者同样一个问题，你的理解和别人的理解的程度很可能是不一样的，如果轻易的看过以后转载了别人的博客，可能意味着一次自我学习或体会的机会的放弃。可能有人会说：”同样一个GFS的架构图，我画也是这样，他画也是这样，因为GFS就是这样设计的“，这里并不是要求任何一个细节都自己去做，而是要有自己的想法、自己的理解，比如GFS分层的原则是什么？为什么这样分层，分层的好出？如果我要是去做的话，我会怎么搞？ 写自己的博客可不是意味着不转载别人的，比如说我看了一篇博客，并且经过实验，却是与博客里面写的完全一致，不多也不少，如果要是自己的写的话，也会写的基本一样，那就没必要再花费时间自己写了。另外，以及纯粹记录性的博客，可以转载，比如“C语言运算符的优先级”，当然转载还是原创都不重要了。 另外，把别人的好的博客作为自己的原创，不但没品，而且自欺欺人。 如果在博客中参考了别人的博客，可以在参考资料里面提及，如果是完全转载，也应注明转载出处。 博客是总结，不是过程写博客有的时候是一个解决问题的过程。为了解决一个问题，今天采用了a方法，发现不行，明天采用了b方法，发现也不行，后天采用c方法，发现行了，那么最终的博客应该是在c方法解决问题后，开始写的。当然，前面的a，b方法，是需要做记录的，但只是博客的原始材料，而不是博客本身。 在刚开始写博客时，我经常出现这种情况：对一个技术不清楚，想了解一下，就开一篇技术博客，边查资料边填写博客，结果基本上就是读、复制、粘贴、读、复制、粘贴…的过程。最后落到自己手里也是空空如也，想起一句谚语：“狗熊掰梆子——掰一个丢一个”，在懊恼自己的缓存为什么这么少的同时，我也想是否是方法不对？后来我想过，要想掌握一项技术、知识，大概需要这样一个过程：实践遇到问题——理论学习问题——实践解决问题——理论总结问题。我想很多情况我是缺少了其中的三个部分，只有“理论学习问题”的过程。 后来，我就改成按下列步骤写博客了： 碰到了问题，如果解决不了，而又比较有价值的话，就先记录下来，作为一篇博客的开篇。 首先，先自己分析问题，基于已有的现象，思考，在笔记本上记录问题与可能的思路。 其次，从外界获取经验或者知识，比如请教别人，google等，学习他们，在笔记本上记录关键点。 然后，在实际中用学来的方法去解决问题，笔记本做好记录，要像水流过水渠一样流淌前面记录的思路。 最后，拿过笔记本，将以上过程再总结成一篇博客。 当然，并不是所有博客都能够先从”实践遇到问题”开始，因为很多情况下都是先从书本理论开始学习的（这也就产生了一定的局限性，有时候你学的很好，反而陷入了固有的框架；有时你学的不好，显得自己更加无知）。这种情况，问题是需要自己总结出来的，比如ULK上会介绍中断和异常的处理机制，这包括中断的过程、CPU的工作、内核的工作、软中断的处理、tasklet等等，我们学习中断，不仅仅是一旦发生中断，Linux内核是按照什么流程去处理，而是要找到这么处理的原因，也就是解决了什么问题。有时，实践验证的成本过高，在有条件的前提下做吧。 知识开始学习的时候，经常是只见树木，不见森林。俗话说：”孤木不成林“，弄上三五棵树，才会有”森林“的感觉。 尽量拒绝三手技术在实际学习或者工作中，一个问题不明白，那么就需要请教别人。如果能够从周围的高手、牛人那得到简单、直接的答复，那是最好的。如果不能，就需要自己在网上查找资料，可能一个问题，林林总总的在网上能搜出很多，选择看哪些就是个问题。尽量去选择原发性的材料，如果你在查gcc的一个编译选项是什么意思，可以使用man手册，如果还不清楚，就去gnu的官方站点去查，最好不要随便从某个转载的技术博客上获取。如果你要找x86平台CPU访问内存的方式，应该从Intel的官方站点去找CPU的资料，最好不要随便在网上找篇博客看了拉到（起码应该先看官方材料）。 别人的博客自然带有别人的理解，而这种理解可能带有一定的主观性，有时甚至是错误的，应该养成从原产地采购的习惯。如果哪天能够发明一项技术，那么这算一手技术；如果你在学习一项成熟的技术，那么该技术就属于二手技术了，如果你再从一个非源发性的地方去学习，那么很可能就是“三手技术”。当然，需要考虑实践成本，有时实在找不到源发性的材料，也不要太勉强自己了。另外，英文文章的水平整体高于国人的文章水平，应该尽量看英文文章。 分清主次、落脚关键点世界万事万物都有联系，凡是和本篇博客的主题有联系的问题，都在本篇博客中描述，是不现实的，也是没必要的。个人认为，一篇技术博客应该不超过两个主题，如果超过了，就应该拆分。但是次要问题可能会有不少，这些次要问题不一定都要解决掉，但一定要分清除优先级，和主题关系比较大的，应首先解决，关系小的，应其次解决，甚至并不在本篇博客中解决。对于没有解决的问题，可以列在”遗留问题“中，对于在其他博客中讨论的问题，给予链接。 根据自己的能力，耕耘到合适的层次。我将掌握一项技术划分为如下层次，在博客中通常应该达到第三个层次： 听说过该技术，了解该技术解决什么问题； 使用过该技术，熟悉该技术的使用方法； 解构过该技术，熟悉该技术的架构、原理； 贯通过该技术，将该技术与自己的以有知识完全融合，可以利用该技术架构或解决其他问题。 技术博客的风格 技术博客不是论文，技术博客由其实用性。当然，也有将论文发在博客上的，比如技术博客的作者大部分应该是工程师，而不是学院派。一篇技术博客可以是小到的一个编程技巧，可以写该技巧的原理、实现方法、好处，但不要写前500后300年的历史介绍和展望未来。技术博客通常关心技术的实用性，而非技术背后理论的复杂性。技术博客也不应该过分求全责备，把文章写的大而全，而应该追求小而精。 技术博客应以陈述语气，个人感情色彩应该过滤掉，技术不是生活的全部。有人写技术博客，常喜欢加入自己的心情，“xxx让我好烦啊”、“xxx很难，我一直持续搞了两天没睡觉”，我个人拒绝这种“呻吟”的风格。 忌罗列代码。代码是实现的过程，而不是原理，列代码是为了看清流程，而非为了列代码而列代码。我个人的习惯是尽量少列代码，如果能够使用校小的篇幅就能说明原理，绝不使用大篇幅的代码。但是如果简单的罗列代码能够一目了然，也绝不浪费过多的笔墨去描述过程。 图片胜过文字。图片配文字比单纯的文字更加方便理解，甚至一张图就可以省略文字了，多画图，少写字是个原则。 考虑时间成本。博客基本上是以时间换知识，因此需要越来越快，记录时间也很必要。 列出时间遗留问题，以备以后解决。 该博客转至Rock3的博客，感谢他的奉献]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android闹钟AlarmManager]]></title>
      <url>2017%2F01%2F03%2FAndroid%E9%97%B9%E9%92%9FAlarmManager%2F</url>
      <content type="text"><![CDATA[Android 闹钟开发设置 本文主要是为了自己做闹钟开发过程中学到的知识点，以及踩到的坑。Android的闹钟和IOS 的闹钟不一样，IOS 的闹钟有设置个数上限50个，Android我查阅了相关资料，并没有说到有设置闹钟上限的说法，如果哪位朋友有查到相关的信息，欢迎交流。众所周知，Android因为是开源，所以存在各种各样的版本，因此开发过程中会遇到在这个手机上能实现的功能，在另一个手机就不能运行的情况，我在做闹钟的情况也遇到过这种情况。下文会把自己学到的知识点，以及踩的坑都会记录下来。 Android 闹钟功能的实现 AlarmManager 的使用 Anroid 闹钟功能的实现，是系统底层已经帮忙实现好了的，并且提供了接口供我们使用，封装在AlarmManager类中。我们当前先分析介绍下AlarmManager 提供的接口。如下图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android心率曲线]]></title>
      <url>2017%2F01%2F03%2FAndroid%E5%BF%83%E7%8E%87%E6%9B%B2%E7%BA%BF%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客模板]]></title>
      <url>2016%2F11%2F01%2F%E5%8D%9A%E5%AE%A2%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 常用命令]]></title>
      <url>2016%2F11%2F01%2Fhexo%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[由于本人很久时间没有写博客，所以以前学习的很多关于hexo的命令知识点都忘了，所以下面罗列一下。 Hexo 安装、升级以及初始化 npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 hexo 各种命令简写 hexo n &quot;博客名称&quot; =&gt; hexo new &quot;博客名称&quot; #这两个都是创建新文章，前者是简写模式 hexo p =&gt; hexo publish hexo g =&gt; hexo generate #生成 hexo s =&gt; hexo server #启动服务预览 hexo d =&gt; hexo deploy #部署 Hexo服务器 hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义IP hexo clean #清除缓存，网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 Hexo 监视文件变动 hexo generate #使用Hexo生成静态文件 hexo generate --watch #监视文件变动 Hexo 完成后部署 两个命令的作用是相同的 hexo generate --deploy hexo deploy --generate hexo deploy -g hexo server -g Hexo 草稿 hexo publish [layout] &lt;title&gt; Hexo 模板 title: 博客模板 date: 2016-11-01 16:32:43 categories: 工具 tags: - 博客模板 Hexo Next主题设置文章摘要 # Automatically Excerpt. Not recommand. # Please use &lt;!-- more --&gt; in the post to control excerpt accurately. auto_excerpt: enable: true length: 150 或者是用以下方法： 以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 Hexo 写文章命令流程 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub Hexo 写作命令 hexo new page &lt;title&gt; hexo new post &lt;title&gt; hexo 推送到服务器上 hexo n #写文章 hexo g #生成 hexo d #部署 #可与hexo g合并为 hexo d -g]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git日常使用命令]]></title>
      <url>2016%2F11%2F01%2FGit%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[常用Git命令清单 Git是版本控制工具，和SVN一样可以用来管理控制代码版本，Git在Github和Android Studio的使用比较多，但是由于公司使用的SVN的版本的控制工具，所以不是很常用Git命令，时间一久就容易忘记，所以记下来一下Git 常用的命令。 - workSpace:工作区 - Index/Stage:暂存区 - Repository:仓库区 - Remote:远程仓库 新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 配置Git Git的配置文件为.gitconfig,它可以在用户的主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [-- global] user.name &quot;[name]&quot; $ git config [-- global] user.email &quot;[email.addresss]&quot; 增加或者删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] #改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 提交代码 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 关于分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 其他 # 生成一个可供发布的压缩包 $ git archive]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MarkDown使用语法]]></title>
      <url>2016%2F11%2F01%2FMarkDown%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[根据资料总结Markdown的优点有如下几点：MarkDown是纯文本，它的兼容性极强，几乎可以使用用所有文本编辑器打开并且编辑。专业的markdown编辑器可以让你专注于文字的编辑而不用关心排版布局。它的格式转换很方便方便，它的文本可以转换为html、电子书等。它的标语法有很好的可读性。 标题的几种格式：平时常用的的文本编辑器中大多是这样模式：输入文本、选中文本、设置标题格式等。而在 Markdown 中，你只需要在文本前面加上 # 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即可，标题字号相应降低。例如：1234567# 这是H1 # ## 这是H2 ## ### 这是H3 ### #### 这是H4 #### ##### 这是H5 ##### ###### 这是H6 ###### 这是H1这是H2这是H3这是H4这是H5这是H6注意：#之间建议保留一个字符空格，这个是标准的markDown语法。 列表的几种样式样式一 样式一 样式一 样式一 样式二 样式二 样式二 样式二 注意：-、和1. 后面都要和后面的文本要保留一个空格。 链接和图片的格式链接格式MarkDown语法中，插入链接是通过【文本】（网址）这样的语法格式实现的。例如：[百度]（www.baidu.com） 图片格式MarkDown语法中，插入链接是通过！【文本】（网址）这样的语法格式实现的。例如：！【图片名称】（图片地址）注意：插入图片和链接的语法很相似，只是在前面多添了一个感叹号。 引用的格式我们写作的时候，有时候经常引用别人的文字，所以我们需要加上引用格式。在MarkDown中，你只需要在你需要引用的文字前面加上&gt; 符号就好了，例如： 曾经沧海难为水，除却巫山不是云 注意：&gt;和后面文本之间要保留一个空格。 粗体和斜体的格式在MarkDwon的语法中，用两个*包含文本就是粗体的语法，用一个*包含文本就是斜体的语法。例如：曾经沧海难为水，除却巫山不是云 代码的引用格式如果只有一段代码没有分行就可以用\’扩起来。如果引用的代码有多行就可以三个点号`放于段首和段尾括起来,段首括起来要加一个回车或者直接按table键或四个空格表示代码块。例如： geren_qu.setOnClickListener(this); geren_wan.setOnClickListener(this); geren_pop_image.setOnClickListener(this); image_add_time.setOnClickListener(this); time_end.setOnClickListener(this); time_start.setOnClickListener(this); tv_shengcheng.setOnClickListener(this); ct_fuyongshuoming.setOnClickListener(this); ct_yaowujieshao.setOnClickListener(this); ct_yaowumingcheng.setOnClickListener(this); top_itv_back.setOnClickListener(this); 显示连接中带括号的图片 123![][1][1]: http://latex.codecogs.com/gif.latex?\prod%20\(n_&#123;i&#125;\)+1 换行的方法你只需要在你想要换行的地方打两个空格，就会自动换行。 分隔符的格式如果你想写分隔符，可以新起一行输入一个减号。如果前后都有段落的时候，要空出一行，例如：-– 符号转义如果你不想你的秒速中用的markdown符号，比如,#,*等，但又不想它被转义，这个时候可以在这些符号前加反斜杠，如\\,\#,\*等进行避免。]]></content>
    </entry>

    
  
  
</search>
