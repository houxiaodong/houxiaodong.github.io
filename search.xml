<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Android-Activty学习小结]]></title>
      <url>2017%2F01%2F04%2FAndroid-Activty%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[Android-Activty学习小结 Activity,fragment,service,broadcast等，是我们日常开发中，使用频率非常高的几大组件。今天找个时间，将这几大组件梳理以下。 Activity知识梳理 Activity的生命周期 Created 个 Activity 的实例被启动时调用的第一个方法。一般情况下，我们都覆盖该方法作为应用程序的一个入口点，在这里做一些初始化数据、设置用户界面等工作。大多数情况下，我们都要在这里从 xml 中加载设计好的用户界面。例如： setContentView(R.layout.main); 当然，也可从 savedInstanceState中读我们保存到存储设备中的数据，但是需要判断 savedInstanceState是否为 null，因为 Activity 第一次启动时并没有数据被存贮在设备中： if(savedInstanceState!=null){ savedInstanceState.get(&quot;Key&quot;); } Started 该方法在 onCreate() 方法之后被调用，或者在 Activity 从 Stop 状态转换为 Active 状态时被调用。Resumed 在 Activity 从 Pause 状态转换到 Active 状态时被调用。Paused 在 Activity 从 Active 状态转换到 Pause 状态时被调用。Stopped 在 Activity 从 Active 状态转换到 Stop 状态时被调用。一般我们在这里保存 Activity 的状态信息。Destroyed 在 Active 被结束时调用，它是被结束时调用的最后一个方法，在这里一般做些释放资源，清理内存等工作。 public class OurActivity extends Activity { protected void onCreate(Bundle savedInstanceState); protected void onStart(); protected void onResume(); protected void onPause(); protected void onStop(); protected void onDestroy(); } 此外，Android 还定义了一些不常用的与生命周期相关的方法可用： protected void onPostCreate(Bundle savedInstanceState); protected void onRestart(); protected void onPostResume(); Activity的几种状态 Activity/runnig:一个新 Activity 启动入栈后，它在屏幕最前端，处于栈的最顶端，此时它处于可见并可和用户交互的激活状态。 Paused:当 Activity 被另一个透明或者 Dialog 样式的 Activity 覆盖时的状态。此时它依然与窗口管理器保持连接，系统继续维护其内部状态，所以它仍然可见，但它已经失去了焦点故不可与用户交互。 Stoped:当 Activity 被另外一个 Activity 覆盖、失去焦点并不可见时处于 Stoped状态。 killed:Activity 被系统杀死回收或者没有被启动时处于 Killed状态。 当我们创建一个Activity的时候，只是决定了Activity的生，但是当我使用activty.finish（）的时候，实际上，和用户按下BACK键一样，告诉Activity Manager该Activity完成了相应的工作，可以被回收。随后Activy Manager 激活处于第二层的Activity并重新入栈，同时原Activity被压入栈的第二层，从Active 的状态转换为paused状态。例如：从 Activity1 中启动了 Activity2，则当前处于栈顶端的是 Activity2，第二层是 Activity1，当我们调用 Activity2.finish()方法时，Activity Manager 重新激活 Activity1 并入栈，Activity2 从 Active 状态转换 Stoped 状态，Activity1. onActivityResult(int requestCode, int resultCode, Intent data)方法被执行，Activity2 返回的数据通过 data参数返回给 Activity1。 Activty 栈Android 是通过一种 Activity 栈的方式来管理 Activity 的，一个 Activity 的实例的状态决定它在栈中的位置。处于前台的 Activity 总是在栈的顶端，当前台的 Activity 因为异常或其它原因被销毁时，处于栈第二层的 Activity 将被激活，上浮到栈顶。当新的 Activity 启动入栈时，原 Activity 会被压入到栈的第二层。一个 Activity 在栈中的位置变化反映了它在不同状态间的转换。Activity 的状态与它在栈中的位置关系如下图所示： 如上所示，除了最顶层即处在 Active 状态的 Activity 外，其它的 Activity 都有可能在系统内存不足时被回收，一个 Activity 的实例越是处在栈的底层，它被系统回收的可能性越大。系统负责管理栈中 Activity 的实例，它根据 Activity 所处的状态来改变其在栈中的位置。 Activity 之间通信使用 Intent 通信在 Android 中，不同的 Activity 实例可能运行在一个进程中，也可能运行在不同的进程中。因此我们需要一种特别的机制帮助我们在 Activity 之间传递消息。Android 中通过 Intent 对象来表示一条消息，一个 Intent 对象不仅包含有这个消息的目的地，还可以包含消息的内容，这好比一封 Email，其中不仅应该包含收件地址，还可以包含具体的内容。对于一个 Intent 对象，消息“目的地”是必须的，而内容则是可选项。在上面的实例中通过 Activity. startActivity(intent)启动另外一个 Activity 的时候，我们在 Intent 类的构造器中指定了“收件人地址”。如果我们想要给“收件人”Activity 说点什么的话，那么可以通过下面这封“e-mail”来将我们消息传递出去： Intent intent =new Intent(CurrentActivity.this,OtherActivity.class); // 创建一个带“收件人地址”的 email Bundle bundle =new Bundle();// 创建 email 内容 bundle.putBoolean(&quot;boolean_key&quot;, true);// 编写内容 bundle.putString(&quot;string_key&quot;, &quot;string_value&quot;); intent.putExtra(&quot;key&quot;, bundle);// 封装 email startActivity(intent);// 启动新的 Activity 那么“收件人”该如何收信呢？在 OtherActivity类的 onCreate()或者其它任何地方使用下面的代码就可以打开这封“e-mail”阅读其中的信息： Intent intent =getIntent();// 收取 email Bundle bundle =intent.getBundleExtra(&quot;key&quot;);// 打开 email bundle.getBoolean(&quot;boolean_key&quot;);// 读取内容 bundle.getString(&quot;string_key&quot;); 上面我们通过 bundle对象来传递信息，bundle维护了一个 HashMap对象，将我们的数据存贮在这个 HashMap 中来进行传递。但是像上面这样的代码稍显复杂，因为 Intent 内部为我们准备好了一个 bundle，所以我们也可以使用这种更为简便的方法： Intent intent =new Intent(EX06.this,OtherActivity.class); intent.putExtra(&quot;boolean_key&quot;, true); intent.putExtra(&quot;string_key&quot;, &quot;string_value&quot;); startActivity(intent); 接收： Intent intent=getIntent(); intent.getBooleanExtra(&quot;boolean_key&quot;,false); intent.getStringExtra(&quot;string_key&quot;); 使用 SharedPreferencesSharedPreferences 使用 xml 格式为 Android 应用提供一种永久的数据存贮方式。对于一个 Android 应用，它存贮在文件系统的 /data/ data/your_app_package_name/shared_prefs/目录下，可以被处在同一个应用中的所有 Activity 访问。Android 提供了相关的 API 来处理这些数据而不需要程序员直接操作这些文件或者考虑数据同步问题。 // 写入 SharedPreferences SharedPreferences preferences = getSharedPreferences(&quot;name&quot;, MODE_PRIVATE); Editor editor = preferences.edit(); editor.putBoolean(&quot;boolean_key&quot;, true); editor.putString(&quot;string_key&quot;, &quot;string_value&quot;); editor.commit(); // 读取 SharedPreferences SharedPreferences preferences = getSharedPreferences(&quot;name&quot;, MODE_PRIVATE); preferences.getBoolean(&quot;boolean_key&quot;, false); preferences.getString(&quot;string_key&quot;, &quot;default_value&quot;); 其它方式Android 提供了包括 SharedPreferences 在内的很多种数据存贮方式，比如 SQLite，文件等，程序员可以通过这些 API 实现 Activity 之间的数据交换。如果必要，我们还可以使用 IPC 方式。 Activity 的 Intent FilterIntent Filter 描述了一个组件愿意接收什么样的 Intent 对象，Android 将其抽象为 android.content.IntentFilter 类。在 Android 的 AndroidManifest.xml 配置文件中可以通过 节点为一个 Activity 指定其 Intent Filter，以便告诉系统该 Activity 可以响应什么类型的 Intent。当程序员使用 startActivity(intent) 来启动另外一个 Activity 时，如果直接指定 intent 了对象的 Component 属性，那么 Activity Manager 将试图启动其 Component 属性指定的 Activity。否则 Android 将通过 Intent 的其它属性从安装在系统中的所有 Activity 中查找与之最匹配的一个启动，如果没有找到合适的 Activity，应用程序会得到一个系统抛出的异常。这个匹配的过程如下： Action 匹配Action 是一个用户定义的字符串，用于描述一个 Android 应用程序组件，一个 Intent Filter 可以包含多个 Action。在 AndroidManifest.xml 的 Activity 定义时可以在其 节点指定一个 Action 列表用于标示 Activity 所能接受的“动作”，例如： &lt;intent-filter &gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;action android:name=&quot;com.zy.myaction&quot; /&gt; &lt;/intent-filter&gt; 如果我们在启动一个 Activity 时使用这样的 Intent 对象： Intent intent =new Intent(); intent.setAction(&quot;com.zy.myaction&quot;); 那么所有的 Action 列表中包含了“com.zy.myaction”的 Activity 都将会匹配成功。Android 预定义了一系列的 Action 分别表示特定的系统动作。这些 Action 通过常量的方式定义在 android.content. Intent中，以“ACTION_”开头。我们可以在 Android 提供的文档中找到它们的详细说明。 URI 数据匹配一个 Intent 可以通过 URI 携带外部数据给目标组件。在 节点中，通过 节点匹配外部数据。mimeType 属性指定携带外部数据的数据类型，scheme 指定协议，host、port、path 指定数据的位置、端口、和路径。如下： &lt;data android:mimeType=&quot;mimeType&quot; android:scheme=&quot;scheme&quot; android:host=&quot;host&quot; android:port=&quot;port&quot; android:path=&quot;path&quot;/&gt; 如果在 Intent Filter 中指定了这些属性，那么只有所有的属性都匹配成功时 URI 数据匹配才会成功。 Category 类别匹配节点中可以为组件定义一个 Category 类别列表，当 Intent 中包含这个列表的所有项目时 Category 类别匹配才会成功。 一些关于 Activity 的技巧锁定 Activity 运行时的屏幕方向Android 内置了方向感应器的支持。在 G1 中，Android 会根据 G1 所处的方向自动在竖屏和横屏间切换。但是有时我们的应用程序仅能在横屏 / 竖屏时运行，比如某些游戏，此时我们需要锁定该 Activity 运行时的屏幕方向，节点的 android:screenOrientation属性可以完成该项任务，示例代码如下： &lt;activity android:name=&quot;.EX01&quot; android:label=&quot;@string/app_name&quot; android:screenOrientation=&quot;portrait&quot;&gt;// 竖屏 , 值为 landscape 时为横屏 ………… &lt;/activity&gt; 全屏的 Activity要使一个 Activity 全屏运行，可以在其 onCreate()方法中添加如下代码实现： // 设置全屏模式 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); // 去除标题栏 requestWindowFeature(Window.FEATURE_NO_TITLE); 在 Activity 的 Title 中加入进度条为了更友好的用户体验，在处理一些需要花费较长时间的任务时可以使用一个进度条来提示用户“不要着急，我们正在努力的完成你交给的任务”。如下图：在 Activity 的标题栏中显示进度条不失为一个好办法，下面是实现代码： // 不明确进度条 requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS); setContentView(R.layout.main); setProgressBarIndeterminateVisibility(true); // 明确进度条 requestWindowFeature(Window.FEATURE_PROGRESS); setContentView(R.layout.main); setProgress(5000); 以上转至]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android遍历两个日期之间每一天]]></title>
      <url>2017%2F01%2F04%2FAndroid%E9%81%8D%E5%8E%86%E4%B8%A4%E4%B8%AA%E6%97%A5%E6%9C%9F%E4%B9%8B%E9%97%B4%E6%AF%8F%E4%B8%80%E5%A4%A9%2F</url>
      <content type="text"><![CDATA[Android遍历两个日期之间每一天 废话不多说，直接上代码，做备份。 import java.text.DecimalFormat; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.List; public class AccountDate { private static transient int gregorianCutoverYear = 1582; /** 闰年中每月天数 */ private static final int[] DAYS_P_MONTH_LY= {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; /** 非闰年中每月天数 */ private static final int[] DAYS_P_MONTH_CY= {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; /** 代表数组里的年、月、日 */ private static final int Y = 0, M = 1, D = 2; /** * 将代表日期的字符串分割为代表年月日的整形数组 * @param date * @return */ public static int[] splitYMD(String date){ date = date.replace(&quot;-&quot;, &quot;&quot;); int[] ymd = {0, 0, 0}; ymd[Y] = Integer.parseInt(date.substring(0, 4)); ymd[M] = Integer.parseInt(date.substring(4, 6)); ymd[D] = Integer.parseInt(date.substring(6, 8)); return ymd; } /** * 检查传入的参数代表的年份是否为闰年 * @param year * @return */ public static boolean isLeapYear(int year) { return year &gt;= gregorianCutoverYear ? ((year%4 == 0) &amp;&amp; ((year%100 != 0) || (year%400 == 0))) : (year%4 == 0); } /** * 日期加1天 * @param year * @param month * @param day * @return */ private static int[] addOneDay(int year, int month, int day){ if(isLeapYear( year )){ day++; if( day &gt; DAYS_P_MONTH_LY[month -1 ] ){ month++; if(month &gt; 12){ year++; month = 1; } day = 1; } }else{ day++; if( day &gt; DAYS_P_MONTH_CY[month -1 ] ){ month++; if(month &gt; 12){ year++; month = 1; } day = 1; } } int[] ymd = {year, month, day}; return ymd; } /** * 将不足两位的月份或日期补足为两位 * @param decimal * @return */ public static String formatMonthDay(int decimal){ DecimalFormat df = new DecimalFormat(&quot;00&quot;); return df.format( decimal ); } /** * 将不足四位的年份补足为四位 * @param decimal * @return */ public static String formatYear(int decimal){ DecimalFormat df = new DecimalFormat(&quot;0000&quot;); return df.format( decimal ); } /** * 计算两个日期之间相隔的天数 * @param begin * @param end * @return * @throws ParseException */ public static long countDay(String begin,String end){ SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date beginDate , endDate; long day = 0; try { beginDate= format.parse(begin); endDate= format.parse(end); day=(endDate.getTime()-beginDate.getTime())/(24*60*60*1000); } catch (ParseException e) { e.printStackTrace(); } return day; } /** * 以循环的方式计算日期 * @param beginDate endDate * @param days * @return */ public static List&lt;String&gt; getEveryday(String beginDate , String endDate){ long days = countDay(beginDate, endDate); int[] ymd = splitYMD( beginDate ); List&lt;String&gt; everyDays = new ArrayList&lt;String&gt;(); everyDays.add(beginDate); for(int i = 0; i &lt; days; i++){ ymd = addOneDay(ymd[Y], ymd[M], ymd[D]); everyDays.add(formatYear(ymd[Y])+&quot;-&quot;+formatMonthDay(ymd[M])+&quot;-&quot;+formatMonthDay(ymd[D])); } return everyDays; } public static void main(String[] args) { List&lt;String&gt; list = AccountDate.getEveryday(&quot;2008-08-29&quot;, &quot;2008-09-02&quot;); for (String result : list) { System.out.println(result); } } } 以上代码转自第三方]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AndroidSwipelayout的使用小结]]></title>
      <url>2017%2F01%2F04%2FAndroidSwipelayout%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[AndroidSwipelayout的使用小结 公司项目最近有用到侧滑删除的功能，网上找了很多开源控件，还是AndroidSwipelayout使用比较方便，自定义程度高，所以打算记录下使用过程，以及使用过程中踩的坑。 第一步引包 从github 上引入包 dependencies { compile &apos;com.android.support:recyclerview-v7:21.0.0&apos; compile &apos;com.android.support:support-v4:20.+&apos; compile &quot;com.daimajia.swipelayout:library:1.2.0@aar&quot; } 第二步创建SwipeLayout布局 在XML上创建SwipeLayout的布局 &lt;com.daimajia.swipe.SwipeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;80dp&quot;&gt; &lt;!-- Bottom View Start--&gt; &lt;LinearLayout android:background=&quot;#66ddff00&quot; android:id=&quot;@+id/bottom_wrapper&quot; android:layout_width=&quot;160dp&quot; android:weightSum=&quot;1&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--What you want to show--&gt; &lt;/LinearLayout&gt; &lt;!-- Bottom View End--&gt; &lt;!-- Surface View Start --&gt; &lt;LinearLayout android:padding=&quot;10dp&quot; android:background=&quot;#ffffff&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--What you want to show in SurfaceView--&gt; &lt;/LinearLayout&gt; &lt;!-- Surface View End --&gt; &lt;/com.daimajia.swipe.SwipeLayout&gt; Surface View 是你想要展示在外面的布局，Bottom View是你想隐藏在后面的布局，用来滑动脱拖出的布局。 第三步初始化SwipeLayout布局 初始化你的SwipeLayout布局，并且设置监听，处理事件。 SwipeLayout swipeLayout = (SwipeLayout)findViewById(R.id.sample1); //set show mode. swipeLayout.setShowMode(SwipeLayout.ShowMode.LayDown); //add drag edge.(If the BottomView has &apos;layout_gravity&apos; attribute, this line is unnecessary) swipeLayout.addDrag(SwipeLayout.DragEdge.Left, findViewById(R.id.bottom_wrapper)); swipeLayout.addSwipeListener(new SwipeLayout.SwipeListener() { @Override public void onClose(SwipeLayout layout) { //when the SurfaceView totally cover the BottomView. } @Override public void onUpdate(SwipeLayout layout, int leftOffset, int topOffset) { //you are swiping. } @Override public void onStartOpen(SwipeLayout layout) { } @Override public void onOpen(SwipeLayout layout) { //when the BottomView totally show. } @Override public void onStartClose(SwipeLayout layout) { } @Override public void onHandRelease(SwipeLayout layout, float xvel, float yvel) { //when user&apos;s hand released. } }); 第四步设置数据SwipeLayout 提供了SwipeAdapter给布局做数据适配，它一共封装了4种数据适配：BaseSwipeAdapter、ArraySwipeAdapter、CursorSwipeAdapter、SimpleCursorSwipeAdapter。下面以BaseSwipeAdapter举例： public class AddListViewSwipeAdapter extends BaseSwipeAdapter { private Context mContext; private LayoutInflater mInflater; public List&lt;String&gt; mlist; SwipeLayout swipeLayout; public AddListViewSwipeAdapter(Context mContext, List&lt;String&gt; list) { this.mContext = mContext; mInflater = LayoutInflater.from(mContext); this.mlist = list; } @Override public int getSwipeLayoutResourceId(int position) { return R.id.listview_swipe; } @Override public View generateView(final int position, ViewGroup parent) { View v = mInflater.inflate(R.layout.item_add_time, null); swipeLayout = (SwipeLayout) v.findViewById(getSwipeLayoutResourceId(position)); swipeLayout.addSwipeListener(new SimpleSwipeListener() { @Override public void onOpen(SwipeLayout layout) { } }); swipeLayout.setOnDoubleClickListener(new SwipeLayout.DoubleClickListener() { @Override public void onDoubleClick(SwipeLayout layout, boolean surface) { Toast.makeText(mContext, &quot;DoubleClick&quot;, Toast.LENGTH_SHORT).show(); } }); return v; } @Override public void fillValues(final int position, View convertView) { //注意：这个里面的position才会是随item变化而递增的，处理list的数据要在这个方法中 Button button = (Button) convertView.findViewById(R.id.delete); TextView tv_cishu = (TextView) convertView.findViewById(R.id.tv_cishu); TextView tv_shijian = (TextView) convertView.findViewById(R.id.tv_shijian); button.setText(&quot;删除&quot;); tv_cishu.setText(&quot;第&quot; + (position + 1) + &quot;次&quot;); tv_shijian.setText(mlist.get(position)); //设置监听事件 swipeLayout.findViewById(R.id.delete).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { mlist.remove(position); for (SwipeLayout s : getOpenLayouts() ) { //关闭侧滑区域 if (s.getOpenStatus() == SwipeLayout.Status.Open) { s.close(); } } notifyDataSetChanged(); } }); } @Override public int getCount() { return mlist.size(); } @Override public Object getItem(int position) { return mlist.get(position); } @Override public long getItemId(int position) { return position; } public List getList() { return mlist; } } 感谢代码家提供的控件，以下是github的链接地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android时间、日期相关类和方法]]></title>
      <url>2017%2F01%2F04%2FAndroid%E6%97%B6%E9%97%B4%E3%80%81%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Android时间、日期相关类和方法Android 系统有三种获取日期的方式：分别是Time、date、Calendar Timeandroid.text.format.Time time = new Time(&quot;GMT+8&quot;); time.setToNow(); year = time.year; month = time.month; day = time.monthDay; minute = time.minute; hour = time.hour; sec = time.second; DateSimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss &quot;); Date curDate = new Date(System.currentTimeMillis());//获取当前时间 dateTime = formatter.format(curDate); CalendarCalendar calendar = Calendar.getInstance(); Clenderyear = calendar.get(Calendar.YEAR); Clendermonth = calendar.get(Calendar.MONTH); Clenderday = calendar.get(Calendar.DAY_OF_MONTH); 获取当前系统的时间System.currentTimeMillis() 注意：Canlendar 和Date 的月份是0~11，要比实际的月份少1。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何写一篇好的技术博客]]></title>
      <url>2017%2F01%2F04%2F%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E7%AF%87%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[在工作过程中，发现对很多东西都一知半解，不是很透澈，到头来很容易模糊，如果有一篇好的技术博客予以总结，一来即使忘记了，回过头来再看，仍然能够从自己的思路中恢复；二来总结一下，还会发现一些潜在问题；三来，有利于大家交流技术。很多大公司都有自己的内部技术博客平台，写好自己的技术博客，对一个技术人员来说，也有一定的成就感。 在网上查阅资料，经常可以看到一些技术博客，要么废话连篇、排版紊乱，要么代码占了篇幅的60%，有些甚至是错的，会让人产生误解。因此，在这总结一下一篇好的技术博客应该是怎样的，同时也规整自己的不良习惯。本篇博客纯属个人的一点想法，是个原则性的东西，切忌逐条对号入座啊。 本篇博客耗时2小时。 带着明确的目的写博客经常看到这种博客，为了写博客而写博客。比如一篇介绍socket接口的使用方法的博客，罗列了一堆代码，凑上几句话：“首先…，其次….，最后…”，就算OK。如果你的目的是“练习如何使用写博客的软件”，或者“罗列接口”，甚至“练习写作的方法”，那么可能达到了目的。但是我想，写一篇技术博客，首先是要明确该博客的目的，通常是学习一项技术、解决一个技术问题什么的，比如“学习Linux内存管理机制”，“解决kernel pannic的问题”，“打发时间”等。 不是所有的的事情都要写一篇博客来记录，要有自己的判断什么东西值的写，什么东西不值的写。 写自己的博客网上相互转载的帖子很多，一篇写的不错的博客经常会被转载，建议不要轻易转载别人的帖子，要写自己的博客。同样一个知识点，或者同样一个问题，你的理解和别人的理解的程度很可能是不一样的，如果轻易的看过以后转载了别人的博客，可能意味着一次自我学习或体会的机会的放弃。可能有人会说：”同样一个GFS的架构图，我画也是这样，他画也是这样，因为GFS就是这样设计的“，这里并不是要求任何一个细节都自己去做，而是要有自己的想法、自己的理解，比如GFS分层的原则是什么？为什么这样分层，分层的好出？如果我要是去做的话，我会怎么搞？ 写自己的博客可不是意味着不转载别人的，比如说我看了一篇博客，并且经过实验，却是与博客里面写的完全一致，不多也不少，如果要是自己的写的话，也会写的基本一样，那就没必要再花费时间自己写了。另外，以及纯粹记录性的博客，可以转载，比如“C语言运算符的优先级”，当然转载还是原创都不重要了。 另外，把别人的好的博客作为自己的原创，不但没品，而且自欺欺人。 如果在博客中参考了别人的博客，可以在参考资料里面提及，如果是完全转载，也应注明转载出处。 博客是总结，不是过程写博客有的时候是一个解决问题的过程。为了解决一个问题，今天采用了a方法，发现不行，明天采用了b方法，发现也不行，后天采用c方法，发现行了，那么最终的博客应该是在c方法解决问题后，开始写的。当然，前面的a，b方法，是需要做记录的，但只是博客的原始材料，而不是博客本身。 在刚开始写博客时，我经常出现这种情况：对一个技术不清楚，想了解一下，就开一篇技术博客，边查资料边填写博客，结果基本上就是读、复制、粘贴、读、复制、粘贴…的过程。最后落到自己手里也是空空如也，想起一句谚语：“狗熊掰梆子——掰一个丢一个”，在懊恼自己的缓存为什么这么少的同时，我也想是否是方法不对？后来我想过，要想掌握一项技术、知识，大概需要这样一个过程：实践遇到问题——理论学习问题——实践解决问题——理论总结问题。我想很多情况我是缺少了其中的三个部分，只有“理论学习问题”的过程。 后来，我就改成按下列步骤写博客了： 碰到了问题，如果解决不了，而又比较有价值的话，就先记录下来，作为一篇博客的开篇。 首先，先自己分析问题，基于已有的现象，思考，在笔记本上记录问题与可能的思路。 其次，从外界获取经验或者知识，比如请教别人，google等，学习他们，在笔记本上记录关键点。 然后，在实际中用学来的方法去解决问题，笔记本做好记录，要像水流过水渠一样流淌前面记录的思路。 最后，拿过笔记本，将以上过程再总结成一篇博客。 当然，并不是所有博客都能够先从”实践遇到问题”开始，因为很多情况下都是先从书本理论开始学习的（这也就产生了一定的局限性，有时候你学的很好，反而陷入了固有的框架；有时你学的不好，显得自己更加无知）。这种情况，问题是需要自己总结出来的，比如ULK上会介绍中断和异常的处理机制，这包括中断的过程、CPU的工作、内核的工作、软中断的处理、tasklet等等，我们学习中断，不仅仅是一旦发生中断，Linux内核是按照什么流程去处理，而是要找到这么处理的原因，也就是解决了什么问题。有时，实践验证的成本过高，在有条件的前提下做吧。 知识开始学习的时候，经常是只见树木，不见森林。俗话说：”孤木不成林“，弄上三五棵树，才会有”森林“的感觉。 尽量拒绝三手技术在实际学习或者工作中，一个问题不明白，那么就需要请教别人。如果能够从周围的高手、牛人那得到简单、直接的答复，那是最好的。如果不能，就需要自己在网上查找资料，可能一个问题，林林总总的在网上能搜出很多，选择看哪些就是个问题。尽量去选择原发性的材料，如果你在查gcc的一个编译选项是什么意思，可以使用man手册，如果还不清楚，就去gnu的官方站点去查，最好不要随便从某个转载的技术博客上获取。如果你要找x86平台CPU访问内存的方式，应该从Intel的官方站点去找CPU的资料，最好不要随便在网上找篇博客看了拉到（起码应该先看官方材料）。 别人的博客自然带有别人的理解，而这种理解可能带有一定的主观性，有时甚至是错误的，应该养成从原产地采购的习惯。如果哪天能够发明一项技术，那么这算一手技术；如果你在学习一项成熟的技术，那么该技术就属于二手技术了，如果你再从一个非源发性的地方去学习，那么很可能就是“三手技术”。当然，需要考虑实践成本，有时实在找不到源发性的材料，也不要太勉强自己了。另外，英文文章的水平整体高于国人的文章水平，应该尽量看英文文章。 分清主次、落脚关键点世界万事万物都有联系，凡是和本篇博客的主题有联系的问题，都在本篇博客中描述，是不现实的，也是没必要的。个人认为，一篇技术博客应该不超过两个主题，如果超过了，就应该拆分。但是次要问题可能会有不少，这些次要问题不一定都要解决掉，但一定要分清除优先级，和主题关系比较大的，应首先解决，关系小的，应其次解决，甚至并不在本篇博客中解决。对于没有解决的问题，可以列在”遗留问题“中，对于在其他博客中讨论的问题，给予链接。 根据自己的能力，耕耘到合适的层次。我将掌握一项技术划分为如下层次，在博客中通常应该达到第三个层次： 听说过该技术，了解该技术解决什么问题； 使用过该技术，熟悉该技术的使用方法； 解构过该技术，熟悉该技术的架构、原理； 贯通过该技术，将该技术与自己的以有知识完全融合，可以利用该技术架构或解决其他问题。 技术博客的风格 技术博客不是论文，技术博客由其实用性。当然，也有将论文发在博客上的，比如技术博客的作者大部分应该是工程师，而不是学院派。一篇技术博客可以是小到的一个编程技巧，可以写该技巧的原理、实现方法、好处，但不要写前500后300年的历史介绍和展望未来。技术博客通常关心技术的实用性，而非技术背后理论的复杂性。技术博客也不应该过分求全责备，把文章写的大而全，而应该追求小而精。 技术博客应以陈述语气，个人感情色彩应该过滤掉，技术不是生活的全部。有人写技术博客，常喜欢加入自己的心情，“xxx让我好烦啊”、“xxx很难，我一直持续搞了两天没睡觉”，我个人拒绝这种“呻吟”的风格。 忌罗列代码。代码是实现的过程，而不是原理，列代码是为了看清流程，而非为了列代码而列代码。我个人的习惯是尽量少列代码，如果能够使用校小的篇幅就能说明原理，绝不使用大篇幅的代码。但是如果简单的罗列代码能够一目了然，也绝不浪费过多的笔墨去描述过程。 图片胜过文字。图片配文字比单纯的文字更加方便理解，甚至一张图就可以省略文字了，多画图，少写字是个原则。 考虑时间成本。博客基本上是以时间换知识，因此需要越来越快，记录时间也很必要。 列出时间遗留问题，以备以后解决。 该博客转至Rock3的博客，感谢他的奉献]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android闹钟AlarmManager]]></title>
      <url>2017%2F01%2F03%2FAndroid%E9%97%B9%E9%92%9FAlarmManager%2F</url>
      <content type="text"><![CDATA[Android 闹钟开发设置 本文主要是为了自己做闹钟开发过程中学到的知识点，以及踩到的坑。Android的闹钟和IOS 的闹钟不一样，IOS 的闹钟有设置个数上限50个，Android我查阅了相关资料，并没有说到有设置闹钟上限的说法，如果哪位朋友有查到相关的信息，欢迎交流。众所周知，Android因为是开源，所以存在各种各样的版本，因此开发过程中会遇到在这个手机上能实现的功能，在另一个手机就不能运行的情况，我在做闹钟的情况也遇到过这种情况。下文会把自己学到的知识点，以及踩的坑都会记录下来。 Android 闹钟功能的实现 AlarmManager 的使用 Anroid 闹钟功能的实现，是系统底层已经帮忙实现好了的，并且提供了接口供我们使用，封装在AlarmManager类中。我们当前先分析介绍下AlarmManager 提供的接口。 设置闹钟 图中紫色箭头所指向的三个方法，便是系统提供的设置闹钟的方法。public void set(int type, long triggerAtMillis, PendingIntent operation) 是设置一次闹钟提醒。public void setRepeating(int type, long triggerAtMillis,long intervalMillis, PendingIntent operation)是设置重复提醒的闹钟。public void setWindow(int type, long windowStartMillis, long windowLengthMillis, PendingIntent operation)是API 19之后设置一次闹钟。 注意：Android闹钟机制在API 19之后，为了节约电量和电池使用，将闹钟由准确传递都变成非准确传递。如下图： 所以在Android开发闹钟的时候，要区分APi版本使用设置闹钟的接口。 // PendingIntent sender = PendingIntent.getBroadcast(context, id, intent, PendingIntent // .FLAG_CANCEL_CURRENT); PendingIntent sender = PendingIntent.getService(context, id, intent, PendingIntent .FLAG_UPDATE_CURRENT); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) { am.setWindow(AlarmManager.RTC_WAKEUP, calMethod(week, calendar.getTimeInMillis()), intervalMillis, sender); } else { if (flag == 0) {// flag 等于0，设置一次闹钟，flag 不等于0，设置重复闹钟。 am.set(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(), sender); } else { am.setRepeating(AlarmManager.RTC_WAKEUP, calMethod(week, calendar.getTimeInMillis ()), intervalMillis, sender); } } 取消闹钟Android 取消闹钟的接口就只有一个。如下图： Android中取消闹钟，只有一个cancel 接口： public void cancel(PendingIntent operation) 注意： Android中要想取消闹钟，因为Android只有一个cancel 接口，并且只传入一个PendingIntent类型的参数，所以要想准确的取消闹钟，必须传入的PendingIntent要和设置闹钟时候传入的PendingIntent一致，否则无法取消闹钟,注意，设置的class 和 action 要和设置闹钟class 和action保持一致； 要想取消闹钟，PendingIntent初始化中第四个参数必须是PendingIntent.FLAG_UPDATE_CURRENT.如下图紫色箭头所指： Android 闹钟进程保活 Android 闹钟响应是通过PendingIntent实现的，设置闹钟的时候会传入一个PendingIntent，同时传入一个距离目前时间的间隔值，到了时间之后，系统便会发出一个消息，然后由PendingIntent去接收消息，并且处理消息。PendingIntent的初始化方式有三种，也就是说，Android闹钟的响应方式有三种，如下图： 如图中所示，获取PendingIntent有三种方式，可以通过Activty，Broadcast,Service 三种方式去获取PendingIntent，响应闹钟发回的消息。Android 常用的闹钟消息处理机制是使用的broadcast和Service，Android 中消息是通过intent来传递的，broadcast 消息的本质也是intent，自从Android 3.1之后，所有的intent 消息，系统会自动给它加上FLAG_EXCLUDE_STOPPED_PACKAGES ,这就导致了，如果app处于停止状态，也就是进程被杀死之后，就无法接收到广播的消息了。想要进程被杀死，也就是停止状态的app 也能够接收到消息，那么需要给消息的intent添加 FLAG_INCLUDE_STOPPED_PACKAGES ,但是由于闹钟的消息是由系统发出来的，我们无法去修改它，所以，我们无法修改Intent，所以我们就尝试去让程序进程保活。 MarsDaemon进程保活使用MarsDaemon的github地址： https://github.com/Marswin/MarsDaemon 第一步 确定自己需要常驻进程的服务，创建一个和它处在同一进程的receiver ,然后新开一个进程创建一个service和receiver,注意：都在在AndroidManifest中注册，进程名可以自己定义：如下图： service1是有业务处理的需要常驻进程的Service，其他三个组件都是额外创建的，里面不需要做任何事情，空实现就可以。 第二步 用你的Application继承DaemonApplication，然后在回调方法getDaemonConfigurations中返回一个配置，将刚才注册的进程名，service类名，receiver类名传进来。如下图： 注意图中紫色箭头所指的地方，必须是进场所在的包名和类名。 第三步杀掉进程尝试。感谢猫九爷阳果果博客参考]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android心率曲线]]></title>
      <url>2017%2F01%2F03%2FAndroid%E5%BF%83%E7%8E%87%E6%9B%B2%E7%BA%BF%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 常用命令]]></title>
      <url>2016%2F11%2F01%2Fhexo%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[由于本人很久时间没有写博客，所以以前学习的很多关于hexo的命令知识点都忘了，所以下面罗列一下。 Hexo 安装、升级以及初始化 npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 hexo 各种命令简写 hexo n &quot;博客名称&quot; =&gt; hexo new &quot;博客名称&quot; #这两个都是创建新文章，前者是简写模式 hexo p =&gt; hexo publish hexo g =&gt; hexo generate #生成 hexo s =&gt; hexo server #启动服务预览 hexo d =&gt; hexo deploy #部署 Hexo服务器 hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义IP hexo clean #清除缓存，网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 Hexo 监视文件变动 hexo generate #使用Hexo生成静态文件 hexo generate --watch #监视文件变动 Hexo 完成后部署 两个命令的作用是相同的 hexo generate --deploy hexo deploy --generate hexo deploy -g hexo server -g Hexo 草稿 hexo publish [layout] &lt;title&gt; Hexo 模板 title: 博客模板 date: 2016-11-01 16:32:43 categories: 工具 tags: - 博客模板 Hexo Next主题设置文章摘要 # Automatically Excerpt. Not recommand. # Please use &lt;!-- more --&gt; in the post to control excerpt accurately. auto_excerpt: enable: true length: 150 或者是用以下方法： 以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 Hexo 写文章命令流程 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub Hexo 写作命令 hexo new page &lt;title&gt; hexo new post &lt;title&gt; hexo 推送到服务器上 hexo n #写文章 hexo g #生成 hexo d #部署 #可与hexo g合并为 hexo d -g]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git日常使用命令]]></title>
      <url>2016%2F11%2F01%2FGit%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[常用Git命令清单 Git是版本控制工具，和SVN一样可以用来管理控制代码版本，Git在Github和Android Studio的使用比较多，但是由于公司使用的SVN的版本的控制工具，所以不是很常用Git命令，时间一久就容易忘记，所以记下来一下Git 常用的命令。 - workSpace:工作区 - Index/Stage:暂存区 - Repository:仓库区 - Remote:远程仓库 新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 配置Git Git的配置文件为.gitconfig,它可以在用户的主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [-- global] user.name &quot;[name]&quot; $ git config [-- global] user.email &quot;[email.addresss]&quot; 增加或者删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] #改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 提交代码 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 关于分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 其他 # 生成一个可供发布的压缩包 $ git archive]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MarkDown使用语法]]></title>
      <url>2016%2F11%2F01%2FMarkDown%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[根据资料总结Markdown的优点有如下几点：MarkDown是纯文本，它的兼容性极强，几乎可以使用用所有文本编辑器打开并且编辑。专业的markdown编辑器可以让你专注于文字的编辑而不用关心排版布局。它的格式转换很方便方便，它的文本可以转换为html、电子书等。它的标语法有很好的可读性。 标题的几种格式：平时常用的的文本编辑器中大多是这样模式：输入文本、选中文本、设置标题格式等。而在 Markdown 中，你只需要在文本前面加上 # 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即可，标题字号相应降低。例如： # 这是H1 # ## 这是H2 ## ### 这是H3 ### #### 这是H4 #### ##### 这是H5 ##### ###### 这是H6 ###### 这是H1这是H2这是H3这是H4这是H5这是H6注意：#之间建议保留一个字符空格，这个是标准的markDown语法，后面不要加空格，不然会显示出#号。 列表的几种样式样式一 样式一 样式一 样式一 样式二 样式二 样式二 样式二 注意：-、和1. 后面都要和后面的文本要保留一个空格。 链接和图片的格式链接格式MarkDown语法中，插入链接是通过【文本】（网址）这样的语法格式实现的。例如：[百度]（www.baidu.com） 图片格式MarkDown语法中，插入链接是通过！【文本】（网址）这样的语法格式实现的。例如：！【图片名称】（图片地址）注意：插入图片和链接的语法很相似，只是在前面多添了一个感叹号,同时上面和下面都要空出一行。 引用的格式我们写作的时候，有时候经常引用别人的文字，所以我们需要加上引用格式。在MarkDown中，你只需要在你需要引用的文字前面加上&gt; 符号就好了，例如： 曾经沧海难为水，除却巫山不是云 注意：&gt;和后面文本之间要保留一个空格。 粗体和斜体的格式在MarkDwon的语法中，用两个*包含文本就是粗体的语法，用一个*包含文本就是斜体的语法。例如：曾经沧海难为水，除却巫山不是云 代码的引用格式如果只有一段代码没有分行就可以用\’扩起来。如果引用的代码有多行就可以三个点号`放于段首和段尾括起来,段首括起来要加一个回车或者直接按table键或四个空格表示代码块。例如： geren_qu.setOnClickListener(this); geren_wan.setOnClickListener(this); geren_pop_image.setOnClickListener(this); image_add_time.setOnClickListener(this); time_end.setOnClickListener(this); time_start.setOnClickListener(this); tv_shengcheng.setOnClickListener(this); ct_fuyongshuoming.setOnClickListener(this); ct_yaowujieshao.setOnClickListener(this); ct_yaowumingcheng.setOnClickListener(this); top_itv_back.setOnClickListener(this); 注意：引用代码的时候，上面也要空出一行。 显示连接中带括号的图片 123![][1][1]: http://latex.codecogs.com/gif.latex?\prod%20\(n_&#123;i&#125;\)+1 换行的方法你只需要在你想要换行的地方打两个空格，就会自动换行。 分隔符的格式如果你想写分隔符，可以新起一行输入一个减号。如果前后都有段落的时候，要空出一行，例如：-– 符号转义如果你不想你的秒速中用的markdown符号，比如,#,*等，但又不想它被转义，这个时候可以在这些符号前加反斜杠，如\\,\#,\*等进行避免。]]></content>
    </entry>

    
  
  
</search>
